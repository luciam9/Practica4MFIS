load time.maude

fmod ID is 
    sort Id .
    protecting STRING .
    op id : String -> Id [ctor] .
endfm

view Id from TRIV to ID is
    sort Elt to Id .
endv

fmod FLOW is
    sort Flow .
    protecting ID .
    protecting POSRAT-TIME-DOMAIN-WITH-INF .

    op flow : Id Time -> Flow [ctor] .
endfm

view Flow from TRIV to FLOW is
    sort Elt to Flow .
endv

fmod GATEWAY is
    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
endfm

fmod NODE is
    sort Node .
    protecting ID .
    protecting POSRAT-TIME-DOMAIN-WITH-INF .
    protecting GATEWAY .
    protecting SET{Id} .
    protecting STRING .
    subsort Id < Set{Id} .

    op start : Id Id -> Node [ctor] .
    op end : Id Id -> Node [ctor] .
    op task : Id String Id Id Time Set{Id} -> Node [ctor] .
    op split : Id Gateway Id Set{Id} -> Node [ctor] .
    op merge : Id Gateway Set{Id} Id -> Node [ctor] .
endfm

view Node from TRIV to NODE is
    sort Elt to Node .
endv

fmod RESOURCE is
    sort Resource .
    protecting ID .
    protecting NAT .
    op resource : Id Nat Nat -> Resource [ctor] .
endfm

view Resource from TRIV to RESOURCE is
    sort Elt to Resource .
endv

fmod TOKEN is
    sort Token .
    protecting ID .
    protecting POSRAT-TIME-DOMAIN-WITH-INF .
    op token : Id Time -> Token [ctor] .
endfm

view Token from TRIV to TOKEN is
    sort Elt to Token .
endv

mod PROCESS is
    sort Process .
    including CONFIGURATION . 
    protecting ID .
    protecting FLOW .
    protecting GATEWAY .
    protecting NODE .
    protecting RESOURCE .
    protecting TOKEN .
    protecting SET{Node} .
    protecting SET{Flow} .
    protecting SET{Token} .
    protecting SET{Resource} .
    subsort Process < Cid .
    subsort Node < Set{Node} .
    subsort Flow < Set{Flow} .
    subsort Token < Set{Token} .
    subsort Resource < Set{Resource} .
    
    op Process : -> Process [ctor] .
    op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
    op resources:_ : Set{Resource} -> Attribute [gather (&)] .

endm

mod BPMN-SEM is
    including PROCESS .

    *** Variables
    var Id1 Id2 Id3 Id4 : Id .
    vars O O' : Oid .
    var Atts : AttributeSet .
    var Conf : Configuration .
    var T T' : Time .
    var TI : TimeInf .
    var Tokens : Set{Token} .
    var Nodes : Set{Node} .
    var Ids : Set{Id} .
    var Flows : Set{Flow} .
    var R : Set{Resource} .
    var N : Nat .
    var No : Node .
    var Name : String .
    var Resources : Set{Resource} .
    var G : Gateway .

    *** Operaciones y Ecuaciones
    op none : -> Configuration [ctor] .

    op reduce : Set{Token} Time -> Set{Token} .
    eq reduce(empty, T) = empty .
    eq reduce((token(Id1, T), Tokens), T') = (token(Id1, T - T'), reduce(Tokens, T')) .
    
    op delta : Configuration Time -> Configuration .
    eq delta(none, T) = none .
    eq delta(< O : Process | gtime: T, tokens: Tokens, Atts >, T') = < O : Process | gtime: T + T', tokens: Tokens, Atts > .

    op minimum : Set{Token} -> Token .
    eq minimum(empty) = empty .
    eq minimum(token(Id1, T)) = token(Id1, T) .
    ceq minimum((token(Id1, T), token(Id2, T'), Tokens)) = minimum((token(Id1, T), Tokens)) if T <= T' .
    ceq minimum((token(Id1, T), token(Id2, T'), Tokens)) = minimum((token(Id2, T'), Tokens)) if T' < T .

    op mte : Configuration -> TimeInf .
    eq mte(none) = INF .
    eq mte(< O : Process | tokens: Tokens, nodes: Nodes, Atts >) = getTime(minimum(readyTokens(Tokens, Nodes))) .
    
    op getTime : Token -> TimeInf .
    eq getTime(empty) = INF .
    eq getTime(token(Id1, T)) = T .
    
    op checkMerge : Set{Id} Set{Token} -> Bool .
    eq checkMerge(empty, empty) = true .
    eq checkMerge(empty, Tokens) = true .
    eq checkMerge((Id1, Ids), Tokens) = ((checkMergeById(Id1, Tokens)) and checkMerge(Ids, Tokens)) .

    op checkMergeById : Id Set{Token} -> Bool .
    eq checkMergeById(Id1, empty) = false .
    eq checkMergeById(Id1, (token(Id1, 0), Tokens)) = true .
    eq checkMergeById(Id1, (token(Id2, T), Tokens)) = checkMergeById(Id1, Tokens) .
    
    op ready : Token Set{Node} Set{Token} -> Bool .
    eq ready(token(Id1, T), empty, Tokens) = true .
    eq ready(token(Id1, T), (end(Id1, Id2), Nodes), Tokens) = false .
    eq ready(token(Id1, 0), (merge(Id2, parallel, (Id3, Ids), Id3), Nodes), Tokens) = checkMerge((Id1, Ids), Tokens) .
    eq ready(token(Id1, T), (No, Nodes), Tokens) = ready(token(Id1, T), Nodes, Tokens) .

    op readyTokens : Set{Token} Set{Node} -> Set{Token} .
    eq readyTokens(empty, Nodes) = empty .
    ceq readyTokens((token(Id1, T), Tokens), Nodes) = (token(Id1, T), readyTokens(Tokens, Nodes)) if ready(token(Id1, T), Nodes, Tokens) .
    ceq readyTokens((token(Id1, T), Tokens), Nodes) = readyTokens(Tokens, Nodes) if not(ready(token(Id1, T), Nodes, Tokens)) . 

    op deleteTokens : Set{Id} Set{Token} -> Set{Token} .
    eq deleteTokens(empty, empty) = empty .
    eq deleteTokens(empty, Tokens) = Tokens .
    eq deleteTokens((Id1, Ids), (token(Id1, T), Tokens)) = deleteTokens(Ids, Tokens) .
    eq deleteTokens((Id1, Ids), (token(Id2, T), Tokens)) = deleteTokens(Ids, (deleteTokens(Id1, Tokens), token(Id2, T))) .

    op getFlow : Set{Id} Set{Flow} -> Set{Flow} .
    eq getFlow (empty,empty) = empty .
    eq getFlow(empty, Flows) = empty .
    eq getFlow((Id1, Ids),Flows) = (getFlowById(Id1, Flows), getFlow(Ids, Flows)) . 

    op getFlowById : Id Set{Flow} -> Set{Flow} .
    eq getFlowById(Id1, (flow(Id1,T), Flows)) = flow(Id1, T) .
    eq getFlowById(Id1, (flow(Id2,T), Flows)) = getFlowById(Id1, Flows) .

    op resourcesAvailables : Set{Id} Set{Resource} -> Bool .
    eq resourcesAvailables(empty, empty) = true .
    eq resourcesAvailables(empty, R) = true .
    eq resourcesAvailables((Id1, Ids), (resource(Id1, N, 0), R)) = false .
    eq resourcesAvailables((Id1, Ids), (resource(Id1, N, s 0), R)) = resourcesAvailables(Ids, R) .

    op takeResources : Set{Id} Set{Resource} -> Set{Resource} .
    eq takeResources(empty, empty) = empty .
    eq takeResources(empty, R) = R .
    eq takeResources((Id1, Ids), (resource(Id1, N, 0), R)) = (resource(Id1, N, 0), takeResources(Ids, R)) .
    
    op returnResources : Set{Id} Set{Resource} -> Set{Resource} .
    eq returnResources(empty, empty) = empty .
    eq returnResources(empty, R) = R .
    eq returnResources((Id1, Ids), (resource(Id1, N, 0), R)) = (resource(Id1, N, 1), returnResources(Ids, R)) .

    op generateToken : Set{Flow} -> Set{Token} .
    eq generateToken(empty) = empty .
    eq generateToken((flow(Id1, T), Flows)) = (token(Id1, T), generateToken(Flows)) .
    *** Reglas

    *** La gestión del tiempo se gestionará con una regla tick.
    crl [tick] : < O : Process | gtime: T, tokens: Tokens, Atts >
    => delta(< O : Process | gtime: T, tokens: Tokens, Atts >, T') if T' := mte(< O : Process | gtime: T, tokens: Tokens, Atts >) /\ 0 < T' /\ (T + T') <= 100 .

    *** Al comenzar la ejecución del proceso anterior tenemos un token en el nodo inicial, una vez su tiempo se hace 0, el token pasará al flujo de salId1a de dicho nodo inicial.
    rl [start] : < O : Process | nodes: (start(Id1, Id2), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id1, 0), Tokens), Atts >
    => < O : Process | nodes: (start(Id1, Id2), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id2, T), Tokens), Atts > .

    *** Una vez se den las condiciones, el token será movId1o a la tarea, y cuando su temporizador sea cero, la ejecución de la misma terminará y el token podrá ser movId1o al flujo de salId1a de la misma.
    crl [flow-task] : < O : Process | nodes: (task(Id1, Name, Id2, Id3, T, Ids), Nodes), flows: (flow(Id2, T'), Flows), tokens: (token(Id1, 0), Tokens), resources: Resources, Atts >
                =>  < O : Process | nodes: (task(Id1, Name, Id2, Id3, T, Ids), Nodes), flows: (flow(Id1, T'), Flows), tokens: (token(Id2, T), Tokens), resources: takeResources(Ids, Resources), Atts > if (resourcesAvailables(Ids, Resources)) .  
    
    *** CUando un token se coloca en un flujo, este token se inicializa con el tiempo de retarso del flujo corresponsiente
    rl [task-flow] : < O : Process | nodes: (task(Id1, Name, Id2, Id3, T, Ids), Nodes), flows: (flow(Id3, T'), Flows), tokens: (token(Id1, 0), Tokens), resources: R, Atts > 
                 =>  < O : Process | nodes: (task(Id1, Name, Id2, Id3, T, Ids), Nodes), flows: (flow(Id3, T'), Flows), tokens: (token(Id3, T'), Tokens), resources: returnResources(Ids, R), Atts > .
                 
    rl [flow-end] : < O : Process | nodes: (end(Id1, Id2), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id2, 0), Tokens), Atts >
                => < O : Process | nodes: (end(Id1, Id2), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id1, 0), Tokens), Atts > .

    rl [flow-mergeE] : < O : Process | nodes: (merge(Id1, exclusive,(Id2, Ids), Id3), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id2, 0), Tokens), Atts > 
                    => < O : Process | nodes: (merge(Id1, exclusive,(Id2, Ids), Id3), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id1, 0), Tokens), Atts > .

    rl [merge-flow] : < O : Process | nodes: (merge(Id1, G, Id2, Id3), Nodes), flows: (flow(Id3, T), Flows), tokens: (token(Id1, 0), Tokens), Atts > 
                   => < O : Process | nodes: (merge(Id1, G, Id2, Id3), Nodes), flows: (flow(Id3, T), Flows), tokens: (token(Id3, T), Tokens), Atts > .

    rl [flow-split] : < O : Process | nodes: (split(Id1, G, Id2, (Id3, Ids)), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id2, 0), Tokens), Atts >
                    => < O : Process | nodes: (split(Id1, G, Id2, (Id3, Ids)), Nodes), flows: (flow(Id2, T), Flows), tokens: (token(Id1, 0), Tokens), Atts > .

    rl [splitE-flow] : < O : Process | nodes: (split(Id1, exclusive, Id2, (Id3, Ids)), Nodes), flows: (flow(Id3, T), Flows), tokens: (token(Id1, 0), Tokens), Atts > 
                    => < O : Process | nodes: (split(Id1, exclusive, Id2, (Id3, Ids)), Nodes), flows: (flow(Id3, T), Flows), tokens: (token(Id3, T), Tokens), Atts > .

    rl [splitP-flow] : < O : Process | nodes: (split(Id1, parallel, Id2, Ids), Nodes), flows: Flows, tokens: (token(Id1, 0), Tokens), Atts > 
                    => < O : Process | nodes: (split(Id1, parallel, Id2, Ids), Nodes), flows: Flows, tokens: (generateToken(getFlow(Ids, Flows)), Tokens), Atts > .

    crl [flow-mergeP] : < O : Process | nodes: (merge(Id1, parallel, Ids, Id2), Nodes), flows: Flows, tokens: Tokens, Atts > 
                     => < O : Process | nodes: (merge(Id1, parallel, Ids, Id2), Nodes), flows: Flows, tokens: (token(Id1, 0), deleteTokens(Ids, Tokens)), Atts > if checkMerge(Ids, Tokens) .

endm
*** Los flujos tienen un retraso.

*** Un token activará una acción sólo si su temporizador está a cero.

*** Las tareas tienen una duración.

*** Mientras el temporizador no sea cero, este no podrá ser utilizado, modelando así la duración asociada a dicho flujo.

*** El comienzo de la ejecución de una tarea requerirá de un token con temporizador a cero en su flujo de entrada y disponer de todos los recursos necesarios.

*** Cuando hay un token con temporizador a cero en el flujo de entrada de una split parallel, su activación producirá un token en cada uno de los flujos de salId1a

*** La activación de un merge paralelo requiere un token con temporizador cero en cada uno de sus flujos de entrada.

*** El atributo resources contendrá el estado de los recursos.